<!-- title: Update 1
layout: default
permalink: /csce645/update-1 -->
## Project Update 1
---
The goal for the first few weeks of my project was to setup the initial pipeline required for smoothing the boundaries in segmented images. This involved researching and developing code to carry out the image processing steps and then testing out simple skeleton construction techniques. I used MATLAB and Python to carry out these initial tasks, but I plan on having the entire pipeline working on Python alone. 

The first step in the pipeline was to find the boundary pixels for each class of objects present in the image. This is a necessary step as the boundary representations of the individual classes will be used to develop and generate the skeleton of the individual objects. While there are a lot of edge detection techniques that could easily be used to obtain the boundaries within the images, these either work on grayscale images and do not always provide the accurate boundaries, or they do provide the boundaries but not in the right sequential order. For that reason, I initially developed my own code that searched across the grids of pixels and obtained all the boundary pixels on both sides of a given boundary (desired), by searching the top, bottom and right pixels to a given pixel (similar to the [von Neumann neighborhood](https://en.wikipedia.org/wiki/Von_Neumann_neighborhood)). However, the problem with this approach was that given the boundary pixels of a class in a random order, it was very hard to obtain a counter-clockwise/clockwise ordering of the pixels, specially for shapes that were concave. And though some methods exist that work for ordering coordinates for concave shapes, my method does not explicitly detect the individual objects present within a class (eg. detecting individual persons within an image). On further exploration, I found out that the boundary tracing function in [MATLAB](https://www.mathworks.com/help/images/ref/bwboundaries.html) did exactly this but for binary images. The function implements the Moore-Neighbor tracing algorithm. In order to carry out quick experiments, I used the MATLAB function while feeding the function single class images, i.e., images containing individual classes while the other classes were blacked out. While this is not ideal, the results of the boundaries obtained were favorable for initial exploration. I was able to obtain sets of clockwise boundaries for the individual objects that were present in the binary images. 

![Update01_00](/assets/images/update01_00.png)

With the obtained boundaries, I was able to find the skeletal representation of the objects by finding the voronoi diagrams using the boundary pixels as the voronoi sites. I used the This helped me obtain the boundaries, as computed by the voronoi diagram, as well as the inner skeletal structure of the the objects. I also implemented this for the original boundaries that I had obtained for the entire image using the python code, however, it did not give me object-level detail of the skeletons. 

In regards to the overall progress, I have been able to accomplish the first primary goal that I mentioned in the project proposal. Ideally, I would have liked to explore skeleton pruning techniques by now, however, that hasn't happened yet and that will be the immediate next goal. 

In terms of the remaining goals, I plan to continue on the path set out previously, with skeleton pruning being the next goal as mentioned in the previous paragraph. I would also like to implement the boundary tracing algorithm on python using inspiration from the MATLAB function. The aim would also be to simultaneously find the boundaries of all the classes and also the disjointed objects in the individual classes in one go. However, I am not sure if that will be possible for a multi-class RGB image.

[Link to Home Page](https://sjvyas.github.io/csce645/)
